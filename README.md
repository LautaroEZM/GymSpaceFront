    
                              ** 🅶🆈🅼🆂🅿🅰🅲🅴 **
#  𝐏𝐫𝐨𝐲𝐞𝐜𝐭𝐨 𝐟𝐢𝐧𝐚𝐥

## **📌 OBJETIVOS**

## ** 🚀  Desarrollar una Plataforma Completa: **

-  Construir una aplicación de página única (SPA) utilizando tecnologías como React, Node, Y MUI garantizando un rendimiento eficiente y una gestión integral de la aplicación.
-  Requisito TECH: Deploy - Asegurar que la aplicación esté desplegada en una plataforma accesible públicamente.

## ** 🚀  Aplicar Principios de Diseño UX/UI: **

-  Implementar Material-UI (MUI) y styled-components para crear una interfaz de usuario atractiva, coherente y altamente funcional.
-  Utilizar styled-components para la creación de estilos, asegurando una presentación visual coherente y agradable.
-  Incorporar react-material-ui-carousel para mejorar la experiencia del usuario al presentar imágenes y contenido visual.
- Requisito TECH: Auth de terceros integrada - Garantizar una experiencia de usuario fluida y segura al permitir registros y logins a través de terceros.

## ** 🚀  Integrar Tecnologías de Vanguardia: **

-  Utilizar herramientas modernas como Axios para realizar solicitudes HTTP de manera eficiente, facilitando la comunicación con el back-end.
-  Integrar react-router-dom para gestionar la navegación entre las diversas vistas de la aplicación de manera eficiente.
-  Requisito TECH: Pasarela de pagos - Implementar pagos seguros para productos y servicios utilizando MercadoPago.

## ** 🚀  Aplicar flujo de trabajo eficiente de GIT: **

-  Seguir buenas prácticas de Git, realizando commits significativos y descriptivos para mantener un historial claro y comprensible del desarrollo.
-  Utilizar el script "start" para servir la aplicación de manera local durante el desarrollo, asegurando un flujo de trabajo suave y colaborativo.
-  Requisito TECH: Dashboard admin - Facilitar la gestión de usuarios y productos mediante un panel de administrador.

## ** 🚀  Pruebas Prácticas: **

-  Implementar pruebas unitarias utilizando las herramientas proporcionadas por React y otras bibliotecas relevantes, garantizando la robustez y confiabilidad del código.
-  Asegurar la estabilidad y confiabilidad de la aplicación mediante pruebas de integración exhaustivas.
-  Requisito TECH: Borrado lógico - Implementar borrado lógico en productos, servicios y usuarios para una gestión más efectiva de los datos.

## ** 🚀  Cumplir con Historias de Usuarios: **

-  Desarrollar funcionalidades basadas en las User Stories definidas para satisfacer las necesidades específicas de los clientes y profesores del gimnasio.
-  Integrar mui-file-input para mejorar la experiencia de carga y manipulación de archivos, facilitando la interacción del usuario.
-  Requisito TECH: Reviews/puntuación - Permitir a los usuarios proporcionar opiniones y valoraciones sobre productos, clases e instructores.

## ** 🚀  Documentar el Flujo y la Lógica del Front-end: **

-  Proporcionar una explicación detallada del flujo y la lógica de construcción del front-end en el README, incluyendo la estructura y organización de los componentes, así como cualquier patrón de diseño utilizado.
-  Requisito TECH: Cloudinary/upload/bucket - Explicar cómo se utiliza Cloudinary para almacenar imágenes de productos y servicios.

## ** 🚀   Aprender y Mejorar Constantemente: **

-  Buscar oportunidades para aprender nuevas tecnologías y enfoques durante el desarrollo del proyecto, manteniéndose al tanto de las últimas actualizaciones y tendencias.
-  Estar abierto a la retroalimentación y realizar mejoras continuas en la aplicación, considerando las actualizaciones de las herramientas utilizadas y buscando siempre la excelencia en el desarrollo.
-  Requisito TECH: Filtros combinados - Mejorar la interfaz del usuario mediante filtros combinados para servicios y productos.


<br />

---

## **⏱ HORARIOS Y FECHAS**

El desarrollo del Proyecto Final (PF) se llevará a cabo durante un período de 4 semanas, estructuradas en tres demos clave. Estas fechas son fundamentales para garantizar un seguimiento detallado y una evaluación progresiva del proyecto.

Semana 1: Kick-Off y Primera Demostración

Inicio: Lunes de la primera semana.

Actividades:

Lanzamiento del proyecto individual.
Desarrollo de filtros en el frente para clases, servicios y productos.
Construcción de las tarjetas de productos.
Implementación de un cargamento con imágenes de carrusel.
Configuración de la navegación en el inicio (MarketPlace, Servicios, Usuarios).

Semana 2: Segunda Demostración

Fecha:
Al finalizar la segunda semana.

Actividades:

Implementar el front-end y back-end.
Finalización de funcionalidades en MarketPlace, Servicios, Usuarios.
Inicio de nuevas características: carrito de compras, pasarela de pagos, autenticación de terceros integrada, administrador del panel.
Implementación del Borrado lógico y Cloudinary/upload/bucket para la carga de imágenes.

Semana 3: Tercera Demostración

Fecha:
Al finalizar la tercera semana.

Actividades:

Finalización exitosa de todos los requisitos TECH.
Incorporación de características adicionales: chatbot de atención al cliente, página de inicio personalizada basada en preferencias.
Aseguramiento de la responsividad de la aplicación.
Documentación completa de la aplicación en el README.

Última Semana: Corrección Personalizada y Coordinación DEMO Final

Fecha:
Cuarta semana, última semana del proyecto.

Actividades:

Corrección personalizada del proyecto.
Coordinación de la fecha de presentación del trabajo (DEMO) con el instructor en caso de finalizar antes del plazo máximo.
Preparación para la presentación final y revisión general del proyecto.
Estos horarios y fechas proporcionan una estructura clara para el desarrollo del Proyecto Final, permitiendo un seguimiento detallado y oportunidades para correcciones y mejoras continuas.

<br />

---

## **📋 SOBRE el levantamiento del fromt...**


Para asegurar el funcionamiento adecuado, sigue estos pasos:

1. Al iniciar el proyecto, ejecuta el comando:

npm install

Esto instalará todas las dependencias necesarias.

2. Posteriormente, inicia el servidor local ejecutando:

```bash
   npm run dev
```

Esta acción activará el manejo de datos locales y permitirá su utilización en diferentes partes de la aplicación.

Siguiendo estos pasos, tendrás acceso a los datos locales almacenados en el proyecto, optimizando el desarrollo y la interacción con la información necesaria.

de esta manera se te levantara el front 

----------------------------------------------------------------------------------------------------------

Compiled successfully!

You can now view material-ui-cra in the browser. 
Compiled successfully!

You can now view material-ui-cra in the browser. 

  Local:            http://localhost:3000        
  On Your Network:  http://192.168.0.105:3000    

Note that the development build is not optimized.
To create a production build, use npm run build. 

webpack compiled successfully

```

Esto significa que ya está corriendo en tu computadora en el puerto 3000. Es decir que podrás acceder a ella desde la URL **`localhost:3000/`**.  es necesario recordar que la app esta deployada y se podra entrar a ella por medio de la ruta 

ruta del deploy del front 

http://gymspace.up.railway.app

---

📖 ENUNCIADO GENERAL

Este proyecto tiene como propósito la creación de una aplicación, guiándonos por la descripción detallada de una plataforma de administración de gimnasios. La aplicación proporcionará una experiencia completa a los usuarios y facilitará la gestión eficiente de servicios y productos del gimnasio.

Objetivos Claves:

Registro y Gestión de Usuarios:

Permitir a los usuarios registrarse en la plataforma para una gestión centralizada de datos, incluyendo membresías, servicios, y productos.

Administración de Membresías:

Brindar a los usuarios la capacidad de gestionar su membresía, desde renovaciones hasta cambios de plan, todo desde la comodidad de la plataforma.

Adquisición de Servicios Adicionales:

Facilitar a los usuarios la compra de servicios adicionales como clases especiales o entrenamientos personalizados.

Compras de Productos:

Ofrecer a los usuarios la posibilidad de explorar y adquirir productos relacionados con el gimnasio, creando una experiencia de compra integral.

Exploración de Clases Disponibles:

Permitir a los usuarios ver las clases disponibles, verificar cupos y realizar registros de participación.
Valoración y Retroalimentación:

Habilitar la valoración y reseñas por parte de los usuarios sobre clases, productos y entrenadores, contribuyendo a la mejora continua.

Notificaciones Personalizadas:

Opción para que los usuarios reciban notificaciones por correo electrónico o mensajes push, manteniéndolos informados sobre eventos, recordatorios de pago y anuncios relevantes.

Verificación de Disponibilidad en Clases:

Incorporar una función de verificación de disponibilidad antes de la inscripción en clases, garantizando una experiencia sin contratiempos.

Gestión Eficiente de Usuarios:

Capacitar a los administradores con herramientas para gestionar eficazmente la información de los usuarios, incluyendo la capacidad de bloquear o desbloquear cuentas según sea necesario.

Flexibilidad en Oferta de Servicios y Productos:

Facilitar a los administradores la capacidad de agregar, editar o eliminar servicios y productos, adaptando la oferta a las necesidades cambiantes del mercado.

Supervisión y Gestión de Clases y Pagos:

Mantener un registro de la disponibilidad de clases, permitir inscripciones, y gestionar eficientemente los pagos, incluyendo recordatorios cuando sea necesario.

Importante:

La aplicación se construirá considerando tecnologías de vanguardia como React, Redux y Material-UI (MUI) para garantizar una interfaz eficiente y amigable.

,,,,,,,,,,,,,,,, 

logica y funcionalidad de cada componente que contiene la app en el Front 

Se desarrollo una aplicación utilizando **React** y **Redux**  y  **MUI* *que contendra las siguientes vistas:

en el carpeta de Components 

**📍  ChatWidget y chatContent |** archivos:

chatContent index: 
Este componente parece ser una interfaz para mostrar mensajes de chat. su lógica y su funcionalidad:

Importaciones:

Se importantes componentes y estilos de @chatscope/chat-ui-kit-reactpara construir la interfaz de chat.
Se utiliza un gancho personalizado llamado useChatbotpara obtener mensajes, estado de escritura y funciones relacionadas con el chat.

Estado:

Utilice el gancho useChatbotpara obtener el estado del chat, que incluye mensajes y un indicador de escritura ( typing).

Renderizado:

Muestra un contenedor principal ( MainContainer) que contiene la interfaz de chat.
El contenedor de chat ( ChatContainer) contiene una lista de mensajes ( MessageList), un indicador de escritura ( TypingIndicator), y un área de entrada de mensajes ( MessageInput).

Mensaje de Bienvenida:

Al iniciar el componente, utilice el mensaje de bienvenida "Hola, ¿en qué puedo ayudarle hoy?" a través del gancho useChatbot.

Renderizado de Mensajes:

Mapea a través de los mensajes y renderiza cada mensaje en un componente de mensaje ( Message).

Entrada de mensaje:

Proporciona un área de entrada de mensajes ( MessageInput) donde los usuarios pueden escribir y enviar mensajes.
Al enviar un mensaje, utilice la función sendMessagedel gancho useChatbot.

Index Widget de chat:

Este componente parece ser un widget de chat que se muestra en algún lugar de la interfaz de usuario. Aquí está la lógica y la funcionalidad:

Importaciones:

Se importantes componentes y estilos de @mui/materialy @mui/icons-materialpara construir el widget.
Se utilizan dos ganchos personalizados: usePopovery useChatbot.
Estado y funciones de los Hooks:

usePopover: Proporciona funciones para gestionar la apertura y cierre de un popover. Devuelve el estado del anclaje ( anchorEl) y funciones para abrir y cerrar el popover.
useChatbot: Proporciona mensajes, estado de escritura y funciones relacionadas con el chat. Devuelve un objeto con mensajes, estado de escritura ( typing), y funciones para enviar mensajes.
Renderizado:

Muestra un botón flotante ( Fab) que, cuando se hace clic, activa un popover con un ícono de chat ( ChatIcon).
Popover:

Utilice el gancho usePopoverpara manejar la apertura y cierre del popover.
Contiene un popover que muestra el componente ChatContentcuando está abierto.
Estilo del botón flotante:

Utilice estilos en línea para posicionar el botón flotante en la esquina inferior derecha de la pantalla.
Funcionalidad del Botón Flotante:

Al hacer clic en el botón flotante, se activa el popover que contiene el componente ChatContent.
Utiliza el estado del popover y funciones asociadas del gancho usePopover.
Contenido del Popover:

Muestra el contenido del chat ( ChatContent) cuando el popover está abierto.
Ambos componentes trabajan juntos para ofrecer una interfaz de chat en una ventana emergente que se activa mediante un botón flotante en algún lugar de la interfaz de usuario. La lógica principal se centra en la gestión de mensajes y la interacción del usuario con la interfaz de chat.

**📍  Date |** archivos:

Date: Este componente utiliza el componente DatePickerde @mui/x-date-pickerspara permitir a los usuarios seleccionar una fecha. Aquí está la lógica y la funcionalidad:

Importaciones:

Se importa el componente DatePickerde @mui/x-date-pickers.
Se importa el componente Containerde @mui/material.
Propiedades del Componente:

El componente recibe dos propiedades ( datey setDate) del componente padre. Estas propiedades se utilizan para gestionar el estado local del componente.
Manejo del Cambio de Fecha ( handleDate):

Defina una función handleDateque se ejecute cuando cambie la fecha seleccionada en el DatePicker.
Dentro de handleDate, se formatea la fecha seleccionada llamando a la función formatDatey luego se actualiza el estado a través de la función setDate.
Formateo de fecha ( formatDate):

Define una función formatDateque toma un objeto de fecha ( value) del DatePickery lo convierte en una cadena de fecha en un formato más amigable.
La fecha se formatea como "AAAA-MM-DD", pero puedes cambiar el formato fácilmente modificando la cadena de formato.
Renderizado:

Devuelve un componente Containercon un ancho máximo de "xs" que contiene el DatePicker.
El DatePickertiene etiqueta "Nacimiento", nombre "nacimiento", formato "AAAA-MM-DD", un valor ( ) valueque proviene de la propiedad datey un controlador de cambio ( onChange) que llama a handleDatecuando cambia la fecha.
Funcionalidad:

Muestra un calendario interactivo ( DatePicker) que permite al usuario seleccionar una fecha.
Utilice las funciones handleDatey formatDatepara manejar y formatear la fecha seleccionada.
Actualiza el estado local ( date) a través de la función setDateproporcionada por el componente padre cuando se selecciona una nueva fecha.
Este componente puede ser utilizado en formularios u otras secciones de la interfaz de usuario donde sea necesario recoger o mostrar información de fecha de una manera interactiva y fácil de entender. 

DetailProduct:
Este componente muestra los detalles de un producto específico. Aquí está la lógica y la funcionalidad:

Importaciones:

React, useEffect, useState: Importa las funciones básicas de React.
axios: Se utiliza para realizar solicitudes HTTP.
useParams, Link: De React Router, useParamsse utiliza para obtener los parámetros de la URL y Linkpara navegar entre las páginas.
Card, CardMedia, Typography, CardContent: Componentes de Material-UI para estructurar y mostrar la información del producto.
Estado Local:

id: Obtiene el parámetro idde los parámetros de la URL usando useParams.
product: Estado que almacena la información del producto.
isLoading: Estado que indica si la carga de datos está en progreso.
error: Estado que almacena un mensaje de error en caso de que ocurra un problema durante la carga de datos.
usoEfecto:

Se utiliza useEffectpara realizar la solicitud HTTP y obtener la información del producto cuando el componente se monta.
Utilice axios.getpara obtener los detalles del producto desde la API.
Actualiza el estado local ( product, isLoading, error) en consecuencia.
Renderizado Condicional:

Si la carga está en curso, se muestra un mensaje de carga.
Si hay un error, se muestra un mensaje de error.
Si la carga se completa y no hay errores, se muestra la información detallada del producto.
Interfaz de usuario:

Utilice un diseño modal con fondo oscuro ( position: fixed) para resaltar los detalles del producto.
Muestra la imagen del producto, nombre, descripción, precio, marca, categoría, estado y stock.
Utilice componentes de Material-UI como Card, CardMedia, Typography, y CardContentpara una presentación atractiva.
Botón de Cierre ( <Link to="/marketplace">...</Link>):

Incluye un botón "X" que utiliza Linkpara volver a la página del mercado cuando se hace clic.
Funcionalidad:

Cargue los detalles del producto desde la API al iniciar el componente.
Muestra una interfaz modal con detalles específicos del producto.
Proporciona una opción para cerrar la ventana modal y regresar a la página del mercado.
Este componente es crucial para mostrar información detallada sobre un producto específico y facilitar la navegación entre la lista de productos y los detalles individuales.


**📍  DetailService |** archivos: 

DetailService.js: 

Importaciones:

React, useEffect, useState: Importa las funciones básicas de React.
axios: Se utiliza para realizar solicitudes HTTP.
useParams, Link: De React Router, useParamsse utiliza para obtener los parámetros de la URL y Linkpara navegar entre las páginas.
Card, CardMedia, Typography, CardContent: Componentes de Material-UI para estructurar y mostrar la información del servicio.
Estado Local:

id: Obtiene el parámetro idde los parámetros de la URL usando useParams.
service: Estado que almacena la información del servicio.
coach: Estado que podría almacenar información sobre el entrenador asociado al servicio (aunque esta parte está actualmente comentada en el código).
isLoading: Estado que indica si la carga de datos está en progreso.
error: Estado que almacena un mensaje de error en caso de que ocurra un problema durante la carga de datos.
usoEfecto:

Se utiliza useEffectpara realizar la solicitud HTTP y obtener la información del servicio cuando el componente se monta.
Utiliza axios.getpara obtener los detalles del servicio desde la API.
Actualiza el estado local ( service, isLoading, error) en consecuencia.
Renderizado Condicional:

Si la carga está en curso, se muestra un mensaje de carga.
Si hay un error, se muestra un mensaje de error.
Si la carga se completa y no hay errores, se muestra la información detallada del servicio.
Interfaz de usuario:

Utilice un diseño modal con fondo oscuro ( position: fixed) para resaltar los detalles del servicio.
Muestra la imagen del servicio, nombre, descripción, categoría, precio, hora de inicio, duración, estado y capacidad.
Utilice componentes de Material-UI como Card, CardMedia, Typography, y CardContentpara una presentación atractiva.
Botón de Cierre ( <Link to="/Services">...</Link>):

Incluye un botón "X" que utiliza Linkpara volver a la página de servicios cuando se hace clic.

Funcionalidad:

Cargue los detalles del servicio desde la API al iniciar el componente.
Muestra una interfaz modal con detalles específicos del servicio.
Proporciona una opción para cerrar la ventana modal y regresar a la página de servicios.
Este componente es esencial para mostrar información detallada sobre un servicio específico y facilitar la navegación entre la lista de servicios y los detalles individuales.


**📍  DetailUsers |** archivos: 

DetailUsers.js: 
Este componente se encarga de mostrar los detalles de un usuario específico. Aquí está la lógica y la funcionalidad:

Importaciones:

React, useEffect, useState: Importa las funciones básicas de React.
useParams, Link: De React Router, useParamsse utiliza para obtener los parámetros de la URL y Linkpara navegar entre las páginas.
axios: Se utiliza para realizar solicitudes HTTP.
Card, CardMedia, Typography, CardContent: Componentes de Material-UI para estructurar y mostrar la información del usuario.
buildReq, API_URL: Utilidades y constantes para la autenticación y la URL de la API.
useAuth0: Un gancho proporcionado por Auth0 para trabajar con la autenticación en la aplicación.
Estado Local:

id: Obtiene el parámetro idde los parámetros de la URL usando useParams.
User: Estado que almacena la información del usuario.
isLoading: Estado que indica si la carga de datos está en progreso.
error: Estado que almacena un mensaje de error en caso de que ocurra un problema durante la carga de datos.
usoEfecto:

Se utiliza useEffectpara realizar la solicitud HTTP y obtener la información del usuario cuando el componente se monta.
Utiliza axios.getpara obtener los detalles del usuario desde la API, también utilizando Auth0 para obtener un token de acceso válido.
Actualiza el estado local ( User, isLoading, error) en consecuencia.
Renderizado Condicional:

Si la carga está en curso, se muestra un mensaje de carga.
Si hay un error, se muestra un mensaje de error.
Si la carga se completa y no hay errores, se muestra la información detallada del usuario.
Interfaz de usuario:

Utiliza un diseño modal con fondo oscuro ( position: fixed) para resaltar los detalles del usuario.
Muestra la imagen del usuario, nombre, género, fecha de nacimiento, correo electrónico, teléfonos de contacto, dirección, matrícula, estado, rol y ID de usuario.
Utilice componentes de Material-UI como Card, CardMedia, Typography, y CardContentpara una presentación atractiva.
Botón de Cierre ( <Link to="/Dashboard">...</Link>):

Incluye un botón "X" que utiliza Linkpara volver al panel de control cuando se hace clic.
Funcionalidad:

Cargue los detalles del usuario desde la API al iniciar el componente, utilizando la autenticación de Auth0.
Muestra una interfaz modal con detalles específicos del usuario.
Proporciona una opción para cerrar la ventana modal y regresar al panel de control.
Este componente es esencial para mostrar información detallada sobre un usuario específico y facilitar la navegación entre la lista de usuarios y los detalles individuales. Además, integra la autenticación de Auth0 para garantizar la seguridad de los datos del usuario.

**📍  ImageCarousel |** archivos: 

ImageCarousel.js: 
Este componente se encarga de mostrar un carrusel de imágenes. Aquí está la lógica y la funcionalidad:

Importaciones:

React: Importa las funciones básicas de React.
Carrusel, Papel, Caja: Componentes de Material-UI utilizados para crear el carrusel.
Datos de ejemplo ( items):

Contiene un arreglo de objetos, cada uno representando un elemento del carrusel.
Cada objeto tiene un nombre, descripción y URL de la imagen.
Componente Funcional ( ImageCarousel):

Devuelve un componente funcional que renderiza el carrusel de imágenes.
Utilice el componente Carouselde "react-material-ui-carousel" para mostrar las imágenes de manera deslizante.
Estilos:

Defina algunos estilos para el contenedor del carrusel ( carouselContainerStyle), la imagen ( carouselImageStyle), el ítem del carrusel ( carouselItemStyle), y el contenido del ítem ( carouselContentStyle).
Renderizado del Carrusel:

Utilice el componente Carousely mapea sobre los elementos en el arreglo items.
Para cada elemento, utilice el componente Papercomo un elemento en el carrusel.
Dentro de cada elemento, se muestra la imagen utilizando el componente img.
Funcionalidad:

Muestra un carrusel de imágenes con descripciones asociadas.
Las imágenes y descripciones son proporcionadas por el arreglo items.
El carrusel utiliza la librería "react-material-ui-carousel" para gestionar el desplazamiento de las imágenes.
Este componente es ideal para mostrar visualmente productos, servicios o cualquier contenido con imágenes en una interfaz de usuario. La flexibilidad del carrusel permite una presentación atractiva de múltiples elementos de manera ordenada.


**📍  Loading |** archivos: 

Loading.js: 
Este componente representa una pantalla de carga y aquí está la lógica y funcionalidad asociada:

Importaciones:

Container: Importa el componente Containerde MUI para estructurar el diseño.
useEffect, useState: Importa funciones de React para gestionar efectos secundarios y estados.
Propiedades:

loading: Es una propiedad booleana que indica si se debe mostrar o no la pantalla de carga.
Imagen de Carga ( image):

Contiene la URL de una imagen de carga (un gif animado).
Componente Funcional ( Loading):

Devuelve un componente funcional que renderiza una imagen de carga dentro de un contenedor.
Renderizado Condicional:

Utilice el componente ContainerMUI con un ancho máximo de "xs" para centrar y limitar la anchura del contenido.
Imagen de Carga:

Dentro del contenedor, se muestra la imagen de carga solo si la propiedad loadinges true.
Si loadinges false, no renderiza nada.
Funcionalidad:

Proporciona una interfaz visual para indicar al usuario que se está cargando contenido.
La imagen de carga es visible solo cuando loadinges true.
Este componente puede ser útil para mejorar la experincia.


**📍  Login |** archivos: 

Login.js: 
Este componente representa la interfaz de inicio de sesión y cierre de sesión y aquí está la lógica y funcionalidad asociada:

Importaciones:

Container: Importa el componente Containerde MUI para estructurar el diseño.
Button: Importa el componente Buttonde MUI para representar botones.
Link: Importación Linkde react-router-domla navegación.
useAuth0: Importa la función useAuth0de @auth0/auth0-reactpara interactuar con el servicio de autenticación Auth0.
style: Importa un módulo de estilo ( login.module.css).
Función logIn:

Utilice useAuth0para obtener funciones y propiedades relacionadas con la autenticación.
Renderiza un botón de inicio de sesión si el usuario no está autenticado ( isAuthenticatedes false).
Renderiza un botón de cierre de sesión si el usuario está autenticado ( isAuthenticatedes true).
Los botones están diseñados con MUI y gestionan las acciones de inicio y cierre de sesión.
Botón de Inicio de Sesión:

Si el usuario no está autenticado, muestra un botón de inicio de sesión en un contenedor de ancho máximo "xs".
El botón utiliza loginWithRedirectpara redirigir al usuario a la página de inicio de sesión de Auth0.
Botón de Cierre de Sesión:

Si el usuario está autenticado, muestra un botón de cierre de sesión en un contenedor de ancho máximo "xs".
El botón utiliza la función logoutpara cerrar la sesión del usuario.
Estilo personalizado:

Utilice un módulo de estilo ( login.module.css) para aplicar estilos personalizados al botón.
Este componente proporciona una interfaz sencilla para que el usuario inicie o cierre sesión, según su estado de autenticación actual.



**📍  PhotoUpload |** archivos: 

loading.gif en este archivo se encontrara una imagen para este espacio

PhotoUpload.js:
Este componente proporciona funcionalidad para cargar y previsualizar fotos, y aquí está la lógica y funcionalidad asociada:

Importaciones:

MuiFileInput: Un componente de entrada de archivo de MUI.
Container, Button: Componentes de MUI para estructurar y representar botones.
Fragment, useState: Importaciones de React para trabajar con fragmentos y estados locales.
styles: Estilos CSS importados para personalizar la apariencia del componente.
storage, ref, uploadBytes, getDownloadURL: Funciones de Firebase para interactuar con el servicio de almacenamiento.
loadingGIF: Una imagen de carga para mostrar durante la carga.
Función PhotoUpload:

Recibe dos propiedades del componente padre: photo(la foto actual) y setPhoto(la función para actualizar la foto).
Utilice estados locales loadingy previewpara gestionar la carga y la previsualización de la foto.
handlePhoto: Función que se activa cuando se selecciona una foto.
Si ya hay una foto, la función la establece nullpara reiniciar la previsualización.
Genera un nombre aleatorio para la imagen.
Crea una referencia de almacenamiento para la imagen.
Habilita el estado de carga ( loading).
Sube la imagen a Firebase y, cuando se completa, obtiene la URL de descarga.
Establece la URL de la foto en el estado del padre ( setPhoto).
Deshabilita el estado de carga ( loading).
Renderiza el componente:
Si hay una foto:
Si la previsualización está desactivada ( !preview), muestra un botón para previsualizar la foto.
Si la previsualización está activada, muestra la foto con un botón para cerrar la previsualización.
Si no hay una foto, muestra un mensaje para enviar una foto.
Utilice MuiFileInputpara permitir la carga de archivos con una restricción de formato.
Estilo personalizado:

Utilice estilos CSS del módulo PhotoUpload.module.csspara personalizar la apariencia de la previsualización y otros elementos.
Este componente proporciona una forma interactiva y visualmente agradable de cargar y previsualizar fotos.


**📍  statusChecker |** archivos: 

statusChecker.js:
Este componente realiza la comprobación del estado y proporciona un mensaje informativo al usuario. Aquí está la lógica y funcionalidad asociada:

Importaciones:

useSelector: Un gancho de Redux para seleccionar datos del estado global.
styles, Typography, Button: Componentes de MUI y estilos importados para personalizar la apariencia.
useAuth0: Un gancho de Auth0 para interactuar con la autenticación.
useDispatch: Un gancho de Redux para despachar al almacén acciones de Redux.
warning: Una acción de Redux importada.
Función status:

Recibe dos parámetros, reduxy auth0.
Comprueba el estado del registro en Redux y la autenticación de Auth0.
Devuelve un valor:
"complete"si el estado en Redux es "unregistered".
"log"si no hay autenticación de Auth0.
"safe"si ambos están en orden.
Componente StatusChecker:

Recibe una propiedad status.
Utiliza useDispatchpara obtener la función de despacho.
Renderiza un componente MUI que muestra un mensaje informativo y un botón "X" para cerrar el mensaje.
Al hacer clic en el botón "X", utilice la acción warningpara desactivar la advertencia.
Estilo personalizado:

Utilice estilos CSS del módulo statusChecker.module.csspara personalizar la apariencia del mensaje y del botón.
Este componente se encarga de evaluar el estado del usuario y mostrar mensajes informativos apropiados. Además, proporciona una forma interactiva para cerrar el mensaje de advertencia.



**📍  Time |** archivos: 

Time.js:
Este componente ( Time.js) proporciona un selector de tiempo utilizando el componente TimePickerde MUI. Aquí está la lógica y funcionalidad asociada:

Importaciones:

TimePicker: Un componente de selección de tiempo de MUI.
Container: Un componente de contenedor de MUI.
Función Time:

Recibe tres propiedades del padre: time, setTime, y labelName.
time: La hora actual seleccionada, un valor en formato de 24 horas.
setTime: Una función para actualizar la hora seleccionada.
labelName: El texto de la etiqueta para el selector de tiempo.
Funciones internas:

handleTime(value): Recibe el valor del selector de tiempo, lo formatea y lo pasa a la función setTimepara actualizar el estado.
formatTime(value): Toma un objeto de tiempo, extrae las horas y los minutos, y devuelve el tiempo formateado en un formato de 24 horas.
Renderizado:

Utilice el componente TimePickerMUI.
label: Se establece con el valor de labelNamepasado por el padre.
value: Se establece con la propiedad timepasada por el padre.
onChange: Se establece con la función handleTimepara manejar los cambios de tiempo.
Estilo y Presentación:

Utilice el componente Containerde MUI para limitar el ancho del selector de t
Este componente se encarga de mostrar y gestionar la selección de tiempo, proporcionando una interfaz fácil de usar para el usuario.


**📍  Time2 |** archivos: 

Time2.js:
Este componente ( Time2.js) proporciona otra opción para seleccionar el tiempo, utilizando los componentes Select, MenuItem, y InputLabelde MUI. Aquí está la lógica y funcionalidad asociada:

Importaciones:

Container: Un componente de contenedor de MUI.
Select: Un componente de selección de MUI.
MenuItem: Un componente de elemento del menú de MUI.
InputLabel: Un componente de etiqueta de entrada de MUI.
Función Time2:

Recibe tres propiedades del padre: time, setTime, y labelName.
time: La hora actual seleccionada, un valor en formato de 24 horas.
setTime: Una función para actualizar la hora seleccionada.
labelName: El texto de la etiqueta para el selector de tiempo.
Estado Local:

hours: Un estado que almacena un array de horas (formato de 24 horas).
minutes: Un estado que almacena una matriz de minutos.
Función handleChange:

Maneja los cambios en la selección del tiempo y actualiza el estado timecon el valor seleccionado.
Función useEffect:

Se ejecuta una vez al montar el componente.
Inicializa los arrays hoursy minutescon los valores correspondientes.
Formatea las horas para asegurarte de que tengan dos dígitos (por ejemplo, "05" en lugar de "5").
Renderizado:

Utilice el componente InputLabelde MUI para mostrar una etiqueta.
Utilice el componente Selectde MUI para la selección de horas.
Utilice el componente MenuItemde MUI para cada opción de hora.
Comentarios:

La sección comentada con el Selecty MenuItempara los minutos parece estar deshabilitada.
Este componente proporciona una interfaz sencilla para seleccionar la hora, permitiendo al usuario elegir entre horas predefinidas. El componente parece estar diseñado para elegir solo la hora


**📍  TopBarMenu |** archivos: 

TopBarMenu.js:
Este componente ( TopBarMenu.js) es la barra de navegación superior de la aplicación. Aquí está la descripción de su estructura y funcionalidad:

Importaciones:

Componentes de MUI: AppBar, Box, MenuItem, Container, IconButton, Typography.
Iconos de MUI: MenuIcon, AccountCircleIcon, ShoppingCartIcon.
Componentes personalizados: LogIn(componente para el inicio
Ganchos y utilidades: useState, useEffect, useNavigate, useSelector.
useAuth0: Un gancho proporcionado por Auth0 para gestionar la autenticación.
axios: Librería para realizar solicitudes HTTP.
Componentes y acciones de Redux: getUser, warning.
Estilos: Estilos personalizados importados de un archivo externo.

Estado Local:

anchorElHome: Guarde el elemento del menú principal.
anchorElIcon: Guarde el elemento del menú del icono de cuenta.
loginOpen: Indica si el menú de inicio de sesión está abierto.
mobileMenuOpen: Indica si el menú móvil está abierto.
mobileMenuPosition: Guarde la posición del menú móvil.
Redux:

warningState: Estado de advertencia desde Redux.
newUser: Datos del usuario desde Redux.
Autenticación0:

user: Datos del usuario proporcionados por Auth0.
isAuthenticated: Indica si el usuario está autenticado.
getAccessTokenSilently: Función para obtener el token de acceso de Auth0.
Funciones:

handleToggleMenuHome: Abre/cierra el menú principal.
updateMobileMenuPosition: Actualiza la posición del menú móvil.
handleToggleMenuIcon: Abra/cierre el menú de inicio de sesión.
handleMobileMenuToggle: Abra/cierre el menú móvil.
handleCloseMenu: Cierra todos los menús abiertos.
handleRedirect: Redirigir a la página especificada.
Efectos:

useEffectpara cargar el usuario y sus detalles desde el backend al autenticarse.
useEffectpara redirigir a la página de registro si el estado del usuario es "unregistered".
Renderizado:

Barra de navegación con enlaces a "INICIO", "MARKETPLACE", "SERVICES" y "DASHBOARD".
Icono de carrito de compras y menú de cuenta con opciones como "Perfil", "Tus productos", "Tus servicios" y "Cerrar sesión".
Menú móvil para enlaces "MARKETPLACE", "SERVICES" y "DASHBOARD".
Comprobación de Estado:

Renderiza un componente de advertencia si el estado actual del usuario no es "seguro" y hay una advertencia activa.
Este componente proporciona una navegación clara y opciones de cuenta para el usuario, adaptándose a las pantallas móviles con un menú desplegable. Además, integra la autenticación de Auth0 y utiliza Redux para gestionar el estado global de la aplicación.

componentes de hooks y chatWidget 

**📍 chatWidget |** archivos: 

useChatbot,js: 
Este gancho ( useChatbot.js) proporciona funcionalidades para gestionar la conversación con un chatbot. Aquí hay una descripción de su estructura y funcionalidades:

Importaciones:

useStatey useEffectde React para gestionar el estado local y efectos secundarios.
axiospara realizar solicitudes HTTP.
Constantes:

CHATBOT_NAME: El nombre del chatbot, establecido como "asistente".
Estado Local:

typing: Indica si el chatbot está escribiendo.
messages: Lista de mensajes en la conversación, cada mensaje tiene un contenido y un remitente.
Funciones:

sendMessage(userMessage): Envía un mensaje del usuario al chatbot, actualiza el estado local con el nuevo mensaje del usuario y el mensaje del chatbot en respuesta.
getResponse(chatMessages): Realiza una solicitud al servidor para obtener una respuesta del chatbot en función de los mensajes de la conversación.
Efectos:

Se ejecuta useEffectcuando se inicializa el componente para enviar un mensaje inicial al chatbot.
Retorno:

{ messages, typing, sendMessage }: Un objeto que contiene la lista de mensajes, el estado de escritura ( typing), y la función para enviar mensajes ( sendMessage).
Detalles:

Cuando se envía un mensaje del usuario, se actualiza el estado local con el mensaje del usuario y se activa la indicación de escritura ( typing).
Se realiza una solicitud al servidor para obtener la respuesta del chatbot.
La respuesta del chatbot se agrega a los mensajes locales después de dejar de escribir ( typingse establece en false).
La función getResponseformatea los mensajes para la solicitud al servidor y maneja las respuestas y errores de la solicitud.
Este gancho es útil para implementar un chatbot en la aplicación, permitiendo una interacción fluida entre el usuario y el chatbot.

useChatWidgetVisibility.js:
El gancho useChatWidgetVisibility.jsse utiliza para determinar si el widget de chat debe estar visible en función de la ubicación actual de la aplicación. Aquí hay una descripción de su estructura y funcionalidades:

Importaciones:

useStatey useEffectde React para gestionar el estado local y efectos secundarios.
useLocationde react-router-dompara obtener la ubicación actual de la aplicación.
Estado Local:

chatWidgetVisible: Indica si el widget de chat debe estar visible o no.
Funciones:

Se utiliza useEffectpara actualizar chatWidgetVisibleen función de la location.pathname. El widget de chat solo estará visible en ciertas rutas especificadas en toDisplayPaths(por ejemplo, '/', '/Marketplace', '/Services').
Retorno:

chatWidgetVisible: Un booleano que indica si el widget de chat debe estar visible en la ubicación actual.
Detalles:

useLocationse utiliza para obtener la ubicación actual de la aplicación.
useEffectse utiliza para actualizar chatWidgetVisiblecada vez que cambia la location.pathname.
La visibilidad del widget de chat se determina según las rutas especificadas en toDisplayPaths.
Este gancho es útil para controlar la visibilidad del widget de chat en la aplicación, asegurando que solo esté visible en las rutas deseadas.

usePopover.js: 

**📍 hooks |** archivos:

useLocalStorage.js: 
El gancho `usePopover.jsProporciona funciones para gestionar la apertura y cierre de un popover en React. Aquí hay una descripción de su estructura y funcionalidades:

Importaciones:

useStatede React para gestionar el estado local.
Estado Local:

anchorEl: Representa el elemento ancla del popover.
Funciones:

openPopover(event): Abre el popover estableciendo anchorElen el elemento actual del evento.
closePopover(): Cierra el popover estableciéndose anchorElen null.
Retorno:

{ anchorEl, openPopover, closePopover }: Un objeto que contiene el elemento ancla actual ( anchorEl), la función para abrir el popover (`openPopoopenPopover ), y la función para cerrar el popover ( closePopover).
Detalles:

Cuando se llama a openPopover, se espera que se le pase un evento que contenga el elemento actual ( event.currentTarget).
anchorElse tu
Este gancho es útil para encapsular la lógica de apertura y cierre de popovers, lo que facilita su reutilización en diferentes componentes.

En la carpeta de PAGES sus componentes son los siguientes 

**📍 CreateProduct |** archivos:

CreateProduct.jsx: 
El componente CreateProduct.jsxes una página que permite a los administradores crear nuevos productos. Aquí tienes una descripción de su estructura y funcionalidades:

Importaciones:

Varios componentes y utilidades de Material-UI y React
PhotoUploadpara manejar la carga de imágenes.
Varios estilos personalizados de Material-UI.
useSelectorde Redux para acceder al estado global.
Variables de Estado:

productData: Un objeto que contiene los detalles del producto, como nombre, descripción, categoría, etc.
newImage: Estado que se actualiza cuando se carga una nueva imagen para el producto.
Manos:

useSelector: Utilizado para acceder al estado global de Redux y obtener información sobre el usuario actual.
Funciones:

handleChange(event): Maneja los cambios en los campos de entrada y actualiza el estado productDataen consecuencia.
handleSubmit(): Maneja la subida del formulario y realiza una solicitud POST al servidor para crear un nuevo producto.
useEffect: Actualiza el campo de imagen cuando productDatacambia newImage.
Efectos Secundarios:

Al cargar la página, se verifica si el usuario actual es un administrador. Si no, se redirige a la página principal.
Renderizado:

Muestra un formulario con campos como nombre, descripción, categoría, marca, etc.
Utilice el componente PhotoUploadpara cargar y previsualizar imágenes.
Contiene campos de entrada para el estado del producto (disponible o no disponible), cantidad en stock y precio.
Al hacer clic en el botón "Crear Producto", se dispara la función handleSubmitpara enviar la solicitud al servidor.
Estilos:

Utilice estilos personalizados de Material-UI para el diseño y la presentación visual.
El formulario está centrado en la pantalla y tiene un diseño limpio.
Restricciones de Acceso:

Verifique si el usuario actual es un administrador antes de permitir el acceso a la página. Si no es un administrador, se redirige a la página principal.
Este componente es crucial para la funcionalidad de administración de productos y demuestra cómo los componentes pueden interactuar con el estado global (en este caso, el estado de Redux) para tomar decisiones basadas en la autorización del usuario.

Errors.jsx: 
El componente Errors.jsxes responsable de manejar y mostrar mensajes de error basados ​​en la validación de datos del producto. Aquí tienes una descripción de su estructura y funcionalidades:

Importaciones:

useEffecty useStatede React para manejar efectos secundarios y el estado local.
Estilos personalizados del módulo CSS Errors.module.css.
Containerde Material-UI para el diseño.
Variables de Estado:

error: Estado que almacena el mensaje de error actual.
Funciones:

useEffect: Se ejecuta cuando productDatacambia. Realiza varias validaciones en los campos de productDatay actualiza el estado erroren consecuencia.
Renderizado:

Muestra un contenedor con el mensaje de error.
Si hay un error, muestra un mensaje de error con el contenido del error.
Si no hay errores, muestra un mensaje indicando que "Todo está bien".
Estilos:

Utilice estilos personalizados del módulo CSS para la presentación visual.
El color y la apariencia de los mensajes de error pueden ser personalizados a través de estos estilos.
Validaciones:

Verifique la longitud y el contenido de los campos del producto, como nombre, categoría, marca, etc.
Realiza validaciones específicas, como la longitud mínima y máxima, la presencia de caracteres alfabéticos, y más.
Cada validación actualiza el estado errorcon un mensaje correspondiente.
Observaciones:

Las validaciones realizadas aquí son específicas para los campos del producto y pueden modificarse según los requisitos del sistema.
La estructura modular permite que este componente sea reutilizable en diferentes partes del sistema.
Este componente es crucial para proporcionar comentarios inmediatos al usuario sobre la validez de los datos que están ingresando o editando para un producto.


**📍 CreateService |** archivos:

CreateService.jsx:
El componente CreateService.jsx es responsable de crear un nuevo servicio. Aquí tienes una descripción de su estructura y funcionalidades:

Importaciones:

Importa varios componentes y funciones de Material-UI, como Container, TextField, Select, MenuItem, InputLabel, Button, Typography, Box, Radio, RadioGroup, FormControlLabel.
Utiliza useStatey useEffectde React para manejar el estado local y los efectos secundarios.
Importa axiospara realizar solicitudes HTTP.
Importa el componente PhotoUploadpara gestionar la carga de imágenes.
Usa useNavigatepara react-router-domla navegación.
Utiliza useSelectorpara react-reduxacceder al estado global.
Variables de Estado:

user: Almacena la información del usuario actual.
loading: URL de la imagen de carga.
serviceData: Almacena los datos del servicio, como nombre, descripción, categoría, precio, etc.
coaches: Almacena la lista de entrenadores recuperada del servidor.
newImage: Almacena la nueva imagen seleccionada para el servicio.
Funciones:

useEffect: Se utiliza para cargar la lista de entrenadores cuando el componente se monta.
handleChange: Maneja cambios en los campos de entrada y actualiza el estado serviceData.
handleTimeChange: Maneja cambios en las horas y minutos del tiempo de inicio y actualiza serviceData.
formatTime: Función para formatear la cadena de tiempo.
handleSubmit: Maneja la creación del servicio, realiza una solicitud HTTP POST al servidor.
Renderizado:

Presenta un formulario con varios campos como nombre, categoría, descripción, precio, capacidad, duración, etc.
Incluye un selector de tiempo para la hora y los minutos de inicio del servicio.
Utilice el componente PhotoUploadpara cargar imágenes.
Muestra el estado del servicio (disponible o no disponible) a través de botones de opción.
Si el usuario es administrador, presenta un menú desplegable para seleccionar un entrenador.
Si el usuario es un entrenador o un administrador, muestra el nombre del entrenador actual.
Utilice botones de Material-UI para realizar la acción de crear el servicio.
Observaciones:

Realiza validaciones en el cliente para garantizar que los datos ingresados ​​sean válidos antes de enviar la solicitud al servidor.
Las funciones useEffecty handleSubmitutilizan solicitudes HTTP para interactuar con el backend y realizar operaciones en la base de datos.
La carga de la lista de entrenadores se realiza una vez que el componente se monta.
Asegúrese de manejar adecuadamente las imágenes y la lógica de carga en su aplicación.

Errors.jsx: 
El componente Errors.jsxse encarga de validar los datos del servicio y mostrar mensajes de error correspondientes. Aquí tienes una descripción de su estructura y funcionalidades:

Importaciones:

Importa useEffecty useStatede React para manejar el estado local y los efectos secundarios.
Importa el estilo del componente desde un archivo externo ( Errors.module.css).
Importa ContainerMaterial-UI para la presentación del contenido.
Variables de Estado:

error: Almacena el mensaje de error correspondiente a los datos del servicio.
Funciones:

useEffect: Se utiliza para realizar validaciones cuando los datos del servicio ( serviceData) cambian.
Las validaciones incluyen:
Longitud del nombre, categoría y descripción.
Formato del nombre y la categoría (solo caracteres alfabéticos).
Longitud de la descripción.
Existencia de una imagen.
Valores no negativos para precio, duración, capacidad.
Selección de un estado y un entrenador.
Si se detecta un error, se establece el mensaje de error correspondiente.
return: Renderiza un componente Containerque muestra el mensaje de error o "Todo listo" según el estado actual.
Observaciones:

El componente realiza validaciones en el cliente para garantizar que los datos ingresados ​​sean válidos antes de enviar la solicitud al servidor.
Asegúrese de que las validaciones en el cliente estén respaldadas por validaciones similares en el servidor para garantizar la integridad de los datos.
Ajusta las validaciones según sea necesario para cumplir con los requisitos específicos de tu aplicación.


**📍 Dashboard |** archivos:

Dashboard.js:
El componente Dashboard.js es una representación de un panel de control con un menú lateral y contenido dinámico. A continuación, se presenta

Importaciones:

Importa varios componentes y elementos de Material-UI y MUI Icons.
Importa el componente UserListdesde un archivo no proporcionado ( components/UserList).
Variables de Estado:

showClientsUserList: Un estado que controla si se debe mostrar la lista de usuarios. Inicialmente, se establece en false.
Funciones:

Dashboard: La función principal del componente.
Defina el diseño del panel de control con un menú lateral y contenido a la derecha.
Utilice el estado showClientsUserListpara determinar si se debe mostrar la lista de usuarios.
El menú lateral contiene categorías como "Gestión", "Finanzas", "Usuarios" y "Personalización" con opciones simuladas.
Al hacer clic en "Usuarios" -> "Personas", se establece showClientsUserListpara truemostrar la lista de usuarios ( UserList).
El contenido a la derecha cambia según las opciones seleccionadas en el menú lateral.
Observaciones:

El menú lateral simula diferentes secciones y opciones, y puedes personalizarlo según las necesidades específicas de tu aplicación.
La lógica de mostrar la lista de usuarios ( UserList) se basa en el estado showClientsUserList.
Asegúrese de tener el componente UserListimplementado para q
Este componente es una plantilla y puede expandirse agregando más lógica y componentes según sea necesario.

**📍 components |** archivos:

CoachesList.js:
El componente CoachesList.js es una tabla de lista de entrenadores con funcionalidades de búsqueda, ordenación y eliminación. A continuación, se describen sus características clave:

Importaciones:

Importa varios componentes y elementos de Material-UI y temas personalizados.
Importa estilos personalizados ( ComponentStyles) para botones y campos de texto.
Variables de Estado:

coaches: Un estado que almacena la lista de entrenadores obtenida de la API.
sortConfig: Un estado que almacena la configuración de ordenación actual (clave y dirección).
hoverRow: Un estado que realiza un seguimiento de la fila sobre la que se encuentra el mouse para resaltarla.
searchTerm: Un estado que almacena el término de búsqueda para filtrar entrenadores.
Funciones:

useEffect: Se utiliza para cargar la lista de entrenadores desde la API cuando el componente se monta.
handleSort: Maneja la lógica de ordenación cuando se hace clic en el encabezado de una columna.
handleSearchTermChange: Maneja cambios en el campo de búsqueda actualizando el estado searchTerm.
filteredCoaches: Filtra los entrenadores basándose en el término de búsqueda.
handleDelete: Maneja la eliminación de un entrenador haciendo una solicitud DELETE a la API.
sortedCoaches: Devuelve la lista de entrenadores ordenada según la configuración actual.
renderTableHeader: Renderiza el encabezado de la tabla con celdas ordenables.
renderTableData: Renderiza los datos de la tabla mostrando información de cada entrenador.
SortableTableCell: Componente funcional para renderizar celdas de encabezado ordenables.
Observaciones:

El componente utiliza temas ( ThemeProvidery CssBaseline) para aplicar estilos.
Se utilizan componentes de Material-UI como Table, TableContainer, TableCell, etc., para construir la interfaz de la tabla.
La tabla es interactiva con opciones de ordenación y eliminación.
La función handleSorty SortableTableCellpermiten ordenar la tabla haciendo clic en los encabezados de las columnas.
El componente está diseñado para ser reutilizable y personalizable según las necesidades del proyecto.
Asegúrese de tener definidos los estilos personalizados ( ComponentStyles) utilizados en el componente.

UserList.js: 
El componenteUserList.js es una tabla de lista de usuarios con funcionalidades de búsqueda, ordenación y acciones (detalles, actualización, eliminación). A continuación, se describen sus características clave:

Importaciones:

Importa varios componentes y elementos de Material-UI y temas personalizados.
Importa estilos personalizados (ComponentStyles ) para botones, campos de texto y estilos de selección.
Importa el componente de carga ( Loading) para mostrar mientras los datos están siendo recuperados.
Variables de Estado:

users: Un estado que almacena la lista de usuarios obtenida de la API.
sortConfig: Un estado que almacena la configuración de ordenación actual (clave y dirección).
hoveredRow: Un estado que realiza un seguimiento de la fila sobre la que se encuentra el mouse para resaltarla.
searchTerm: Un estado que almacena el término de búsqueda para filtrar usuarios.
selectedCategory: Un estado que almacena la categoría seleccionada para la búsqueda.
loading: Un estado que controla si los datos están siendo cargados, para mostrar el componente de carga.
Funciones:

useEffect: Se utiliza para cargar la lista de usuarios desde la API cuando el componente se monta.
handleSort: Maneja la lógica de ordenación cuando se hace clic en el encabezado de una columna.
handleCategoryChange: Maneja cambios en la categoría seleccionada para la búsqueda.
handleSearchTermChange: Maneja cambios en el campo de búsqueda actualizando el estadosearchTerm.
filteredUsers: Filtra los usuarios calculando en la categoría seleccionada y el término de búsqueda.
handleDelete: Maneja la eliminación de un usuario haciendo una solicitud DELETE a la API.
sortedUsers: Devuelve la lista de usuarios ordenada según la configuración actual.
renderTableHeader: Renderiza el encabezado de la tabla con celdas ordenables.
renderTableData: Renderiza los datos de la tabla mostrando información de cada usuario.
SortableTableCell: Componente funcional para renderizar celdas de encabezado ordenables.
Observaciones:

El componente utiliza temas (ThemeProvidery CssBaseline) para aplicar estilos.
Se utilizan componentes de Material-UI como Table,TableContainer, TableCell, etc., para construir la interfaz de la tabla.
La tabla es interactiva con opciones de ordenación y acciones (detalles, actualización, eliminación).
La función handleSortySortableTableCellpermiten ordenar la tabla haciendo clic en los encabezados de las columnas.
El componente incluye opciones para cambiar la categoría de búsqueda y realizar búsquedas por diferentes campos de usuario.
Muestra un componente de carga (Loading ) mientras los datos están siendo recuperados.
Asegúrese de tener definidos los estilos personalizados ( ComponentStyles) utilizados en el componente.



**📍 Form |** archivos:

Errors.jsx:
El componente Errors.jsx es un componente encargado de validar los datos del formulario y mostrar mensajes de error si los datos no cumplen con ciertos criterios. A continuación, proporciona una descripción y observaciones sobre el componente:

Importaciones:

Importa useEffecty useStatede React.
Importa estilos desde un archivo llamado Errors.module.css.
Importa el componente Containerde Material-UI para la maquetación.
Accesorios:

Recibe las propiedades del formulario ( userData), asumiendo que contiene campos como firstName, lastName, address, gender, birth, email, phone, contactPhone, y photo.
Variables de Estado:

error: Estado que almacena el mensaje de error.
Funciones:

useEffect: Se utiliza para realizar la validación cuando cambian los datos del formulario ( userData). Contiene múltiples condiciones que comprueban diferentes aspectos de los datos del formulario y establece el estado de erroren caso de que se encuentren problemas en los datos.
Validaciones Realizadas:

Verifique la longitud del firstNamey lastName, asegurándose de que estén entre 4 y 12 caracteres.
Comprueba si namey lastnamecontienen solo caracteres alfabéticos.
Verifique el formato del address, asegurándose de que tenga al menos 4 caracteres, al menos un número y al menos una letra.
Verifica si se ha seleccionado un valor para gender.
Verifique si se ha seleccionado una fecha de nacimiento diferente de 'AAAA-MM-DD'.
Verifica el formato del correo electrónico ( email).
Verifique el formato de los números de teléfono ( phoney contactPhone), asegurándose de que tengan entre 10 y 11 caracteres y sean numéricos.
Asegúrese de que se haya cargado una foto ( photo).
Renderización:

Renderiza un componente Containerde Material-UI con estilos personalizados.
Renderiza un mensaje de error si la longitud de errores mayor que 1; de lo contrario, muestra un mensaje indicando que "Todo está bien".
Observaciones:

Asegúrese de que los nombres de las propiedades de userDatacoincidan con los nombres utilizados en las validaciones.
Las validaciones son específicas y abordan diferentes aspectos de los datos del formulario.
Este componente es útil para proporcionar retroalimentación instantánea al usuario sobre la validez de los datos ingresados ​​en el formulario.


Login.jsx:
El componente Login.jsx es un formulario de inicio de sesión que permite a los usuarios ingresar su correo electrónico y contraseña. Aquí hay una descripción y observaciones sobre el componente:

Importaciones:

Importa varios componentes de Material-UI, como Container, TextField, IconButton, y Button.
Importa iconos de Material-UI para gestionar la visibilidad de la contraseña.
Importa el tema ( theme) de algún lugar no proporcionado en el código.
Variables de Estado:

userData: Estado que almacena la información del usuario, en este caso, el correo electrónico y la contraseña.
showPassword: Estado que controla la visibilidad de la contraseña. Contiene un objeto con dos propiedades: iconpara el icono de visibilidad y valuepara indicar si la contraseña debe mostrarse o no.
Funciones:

handleShowPassword: Cambia el estado de visibilidad de la contraseña cuando se hace clic en el icono de visibilidad.
handleChange: Maneja el cambio en los campos de entrada ( emaily password) y actualiza el estado userDataen consecuencia.
Renderización:

Renderiza un componente Containerde Material-UI con un ancho máximo de "xs" y estilos personalizados.
Renderiza dos campos de entrada ( TextField) para el correo electrónico y la contraseña.
Renderiza un icono de visibilidad de contraseña ( IconButton) que cambia su apariencia y cambia la visibilidad de la contraseña cuando se hace clic.
Renderiza un botón de inicio de sesión ( Button) dentro de otro contenedor Container.
Observaciones:

Asegúrese de que los nombres de las propiedades ( id) en los campos de entrada ( TextField) coincidan con las propiedades esperadas en el estado userData.
Faltan funciones o llamadas para el manejo de la autenticación real (enviar datos al servidor, manejar respuestas, etc.).
Se supone que stylescontiene clases de estilo para la maquetación, pero no se proporciona en el código proporcionado. Asegúrese de tener esos estilos definidos.
El color del botón ( color={theme.primary}) depende del tema ( theme) que se importa pero no se proporciona en el código. Asegúrese de que esta referencia al tema esté definida en algún lugar.

SignUp.jsx:
El componente SignUp.jsx es un formulario de registro que permite a los usuarios proporcionar información personal. Aquí hay una descripción y observaciones sobre el componente:

Importaciones:

Importa varios componentes de Material-UI, como Container, TextField, Button, Select, MenuItem, InputLabel.
Importa el tema ( theme) de algún lugar no proporcionado en el código.
Importa DatePickerde @mui/x-date-pickers.
Importa componentes y utilidades de Redux, React Router y Auth0.
Importa un componente Errorsque parece manejar errores de validación en el formulario.
Importa axiospara realizar solicitudes HTTP.
Variables de Estado:

userData: Estado que almacena la información del usuario durante el proceso de registro.
photo: Estado que almacena la foto del usuario.
newUser: Estado obtenido del almacenamiento Redux que probablemente contiene información del usuario (¿actualización del perfil?).
Funciones:

handleChange: Maneja el cambio en los campos de entrada y actualiza el estado userDataen consecuencia.
handleBirth: Maneja el cambio en la fecha de nacimiento y actualiza el estado userData.
formatDate: Formatee la fecha seleccionada del componente DatePicker.
handleSubmit: Maneja la presentación del formulario, realiza una solicitud HTTP PUT al servidor para actualizar la información del usuario.
Efectos:

Un efecto para inicializar el campo de correo electrónico ( email) si se proporciona un nuevo usuario.
Renderización:

Renderiza un componente Containerde Material-UI con estilos personalizados.
Renderiza varios campos de entrada ( TextField) para el nombre, apellido, dirección, teléfonos y correo electrónico.
Renderiza un componente Selectpara seleccionar el género.
Renderiza un componente DatePickerpara seleccionar la fecha de nacimiento.
Renderiza un botón de registro( Button) que ejecuta la función handleSubmit.
Renderiza un componente Errorspara manejar la visualización de mensajes de error.
Renderiza un componente PhotoUploadpara cargar y mostrar la foto del usuario.
Observaciones:

El componente Errorsespera que userDatatenga propiedades específicas para validar. Asegúrese de que estas propiedades estén definidas en el estado userData.
El componente parece depender de un flujo de autenticación a través de Auth0, asegúrese de que se haya configurado correctamente.
Faltan algunas validaciones y manejo de errores en las funciones de manejo ( handleChange, handleBirth, handleSubmit). Asegúrese de agregar validaciones necesarias para asegurar datos válidos antes de enviar al servidor.
Se espera que Redux esté configurado correctamente para usar las funciones como useSelectory useDispatch. Asegúrese de que estas funciones estén disponibles.
Algunos valores iniciales, como enrollmentDate, status, y systemRole, se establecen en valores fijos. Asegúrese de que estos valores sean los adecuados para su caso de uso.

 
**📍 Home |** archivos:

Home.jsx:
El componente Home.jsxparece ser bastante simple y principalmente se encarga de renderizar un componente ImageCarousel. Aquí hay una descripción:

Importaciones:

Importa el componente ImageCarouseldesde algún directorio no proporcionado en el código.
Funciones:

Home: Función del componente que renderiza el componente ImageCarousel.
Renderización:

Renderiza un contenedor div.
Dentro del contenedor, renderiza el componente ImageCarousel.
Observaciones:

El componente Homeno parece contener lógica compleja, más allá de mostrar un carrusel de imágenes. La funcionalidad real probablemente se encuentra en el componente ImageCarousel.
Asegúrese de que la importación de ImageCarouselsea correcta y de que el componente esté configurado adecuadamente.
Si se espera que haya más contenido en la página de inicio en el futuro, este componente puede expandirse para incluir más secciones y contenido. Por ahora, es bastante simple y sirve como un punto de entrada para el carrusel de imágenes.


**📍 Merkatplace |** archivos:

FilterBar: 
El componente FilterBar.jsse encarga de renderizar la barra de filtros para las categorías y el rango de precios en la página de un mercado ( Merkatplace). Aquí está una descripción detallada del componente:

Importaciones:

React, useState: Importa el paquete React y la función useStatepara manejar el estado del componente.
Box, Collapse, TextField, Typography, Slider, Button: Importa componentes de Material-UI utilizados para la estructura y presentación del filtro.
OrangeButtonFilter, OrangeOutlinedButton: Importa estilos de botones específicos para el filtro desde un archivo de estilos ( ComponentStyles).
Accesorios:

allCategories: Un array que contiene todas las categorías disponibles.
selectedCategories: Matriz de categorías seleccionadas.
handleCategoryFilter: Función para manejar los cambios en la selección de categorías.
priceRange: Rango de precios actuales.
handleManualPriceChange: Función para manejar los cambios manuales en los campos de precio.
handlePriceFilter: Función para manejar los cambios en el rango de precios mediante el control deslizante.
filterOpen: Estado que indica si la barra de filtros está abierta o cerrada.
maxProductPrice: Precio máximo de los productos disponibles.
Estado:

priceRange: Estado local que almacena el rango de precios actual. Se inicializa con [0, maxProductPrice].
Renderización:

Utilice el componente Collapsede Material-UI para mostrar u ocultar la barra de filtros dependiendo del estado filterOpen.
Renderiza un contenedor ( Box) con secciones para categorías y rango de precios.
Para las categorías, cree botones de filtro naranjas ( OrangeButtonFilter) para cada categoría disponible. Estos botones cambian de estilo si están seleccionados.
Para el rango de precios, utilice un control deslizante ( Slider) junto con campos de texto para permitir la selección manual del rango de precios.
Se utiliza un botón naranja ( OrangeOutlinedButton) para aplicar los filtros.
Observaciones:

La lógica de manejo de los cambios en el rango de precios y las categorías se delega a las funciones proporcionadas como accesorios.
Los estilos y colores utilizados están personalizados para ajustarse a la apariencia general de la aplicación.
Se utiliza un enfoque de estado local ( priceRange) para mantener el rango de precios actualizado internamente antes de que se apliquen los cambios.lterBar.js:


Marketplace.js:
El componente Marketplace.js representa la página principal del mercado ( Marketplace). Aquí hay una descripción detallada del componente:

Importaciones:

React, useState, useEffect: Importa React y las funciones useStatey useEffectpara manejar el estado y los efectos secundarios del componente.
CssBaseline, Box, Typography, ThemeProvider, IconButton, AppBar, Toolbar, Badge: Importa componentes de Material-UI para establecer la apariencia y estructura de la página.
AddCircleOutlineIcon, SortIcon, FilterListIcon: Iconos de Material-UI utilizados en la barra de herramientas.
OrangeOutlinedButton, LinkNoDeco: Estilos y componentes de enlace sin decoración desde archivos de estilos y componentes personalizados.
FilterBar, SortMenu, ProductList: Componentes internos para la barra de filtros, menú de orden y lista de productos.
useSelector: Hook de React-Redux para seleccionar partes del estado de Redux.
Estado:

products: Estado que almacena la lista de productos.
filterOpen: Estado que indica si la barra de filtros está abierta o cerrada.
selectedCategories: Estado que almacena las categorías seleccionadas.
loading: Estado que indica si los datos se están cargando.
sorting: Estado que almacena el tipo y orden de clasificación de los productos.
anchorEl: Estado que almacena la referencia al elemento que activa el menú de orden.
noProducts: Estado que indica si no se encontraron productos.
priceRange: Estado que almacena el rango de precios actual.
Efectos secundarios:

Utilice useEffectpara cargar los productos desde una API al montar el componente.
Funciones:

handleCategoryFilter: Función para manejar los cambios en la selección de categorías.
handlePriceFilter: Función para manejar los cambios en el rango de precios mediante el control deslizante.
handleManualPriceChange: Función para manejar los cambios manuales en los campos de precio.
handleSortClick: Función para manejar el clic en el icono de ordenar y abrir el menú de orden.
handleSortChange: Función para manejar los cambios en el tipo de orden seleccionado.
sortedProducts: Función que devuelve la lista de productos ordenada según las opciones de clasificación seleccionadas.
Renderización:

Renderiza una barra de herramientas ( AppBar) con botones para abrir la barra de filtros, abrir el menú de orden y, en caso de ser un administrador, agregar un nuevo producto.
Utilice los componentes internos FilterBary para gestionar los filtros, el menú de orden y la lista de SortMenuproductos ProductList, respectivamente.
Muestra un mensaje si no se encuentran productos y no están en estado de carga.
Muestra un indicador de carga ( Loading) mientras se están cargando los datos.
Observaciones:

Utilice estilos y colores personalizados para ajustarse al diseño general de la aplicación.
La lista de productos se carga mediante una solicitud a una API externa.
La lógica de filtrado y clasificación se delega a funciones específicas.
La adición de un nuevo producto solo está habilitada para usuarios con el rol de administrador.
Hace uso de componentes y estilos personalizados para mantener una apariencia coherente en toda la aplicación.
Este componente centraliza la lógica y la presentación de la página principal del mercado, proporcionando funcionalidades de filtrado, orden y visualización de productos.

ProductList.js:
El componente ProductList.jsse encarga de renderizar la lista de productos en el mercado. Aquí tienes una descripción detallada del componente:

Importaciones:

React: Importa React para la creación de componentes.
Box, Grid, Rating, Typography, CardMedia, CardContent, CardActions, Button: Componentes de Material-UI para la estructura y diseño del componente.
IconButton, AddShoppingCartIcon: Componentes de Material-UI para el botón de añadir al carrito.
SmallOrangeOutlinedButton, ProductCard: Estilos y componentes de tarjeta desde archivos de estilos y componentes personalizados.
Link: Componente de React Router para la navegación.
Propiedades:

sortedProducts: Función que devuelve la lista de productos ordenada según las opciones de clasificación seleccionadas.
Renderización:

Utilice un componente Boxde Material-UI para contener la lista de productos.
Mapea sobre la lista de productos ordenados y renderiza una tarjeta ( ProductCard) para cada producto.
Cada tarjeta contiene una imagen, información del producto (nombre y precio), una acción para ver detalles ( VIEW DETAIL), y un botón para añadir al carrito.
Observaciones:

Las imágenes de los productos se muestran mediante el componente CardMedia.
La información del producto (nombre y precio) se muestra mediante los componentes Typography.
Utilice estilos personalizados para ajustarse al diseño general de la aplicación.
Los botones para ver detalles y añadir al carrito están vinculados a las rutas correspondientes.
La valoración de los productos se representa mediante el componente Rating.
La funcionalidad de agregar al carrito actualmente solo incluye un icono, y se puede personalizar según la lógica específica de su aplicación.
Los productos se muestran en una cuadrícula ( Grid) con un diseño receptivo basado en el tamaño de la pantalla.
Este componente se enfoca en la presentación de la lista de productos y proporciona enlaces para ver detalles y agregar productos al carrito. La estructura modular permite una fácil adaptación y personalización según los requisitos específicos del proyecto.

SortMenu.js:
El componente SortMenu.js se encarga de renderizar un menú desplegable para seleccionar opciones de clasificación (ordenar por precio o alfabéticamente). Aquí tienes una descripción detallada del componente:

Importaciones:

React: Importa React para la creación de componentes.
StyledMenu, StyledMenuItem: Componentes de estilo desde archivos de estilos ( ComponentStyles).
Propiedades:

anchorEl: Elemento ancla para el menú desplegable.
handleSortChange: Función para manejar el cambio de opciones de clasificación.
sorting: Objeto que representa el estado actual de la clasificación (tipo y orden).
setAnchorEl: Función para establecer el elemento ancla.
Renderización:

Utilice un componente StyledMenu(un menú estilizado) de Material-UI.
Renderiza dos opciones de clasificación ( StyledMenuItem): una para ordenar por precio y otra para ordenar alfabéticamente.
Cada opción muestra una etiqueta y un indicador de dirección ( ▲o ▼) según la opción de clasificación actual.
Eventos:

La función handleSortChangese llama al hacer clic en una opción de clasificación. Esta función se encarga de actualizar el estado de la clasificación.
Observaciones:

Los estilos personalizados ( StyledMenuy StyledMenuItem) son utilizados para dar un diseño específico al menú y sus elementos.
El menú se muestra solo si anchorEles un elemento existente (no nulo), lo que indica que el menú está anclado a algún elemento en la interfaz.
La dirección ( ▲o ▼) indica si la clasificación es ascendente o descendente para la opción seleccionada.
Este componente proporciona una interfaz fácil de usar para que el usuario seleccione las opciones de clasificación deseadas, lo que facilita la personalización y mejora la experiencia del usuario al interactuar con la lista de productos en el mercado.


**📍 NotFound |** archivos:

NotFound:
El componente NotFoundes un componente funcional simple que representa una página "Not Found" (no encontrado). Aquí tienes una descripción del componente:

Importaciones:

style: Importa un módulo de estilos ( NotFound.module.css).
Renderización:

Devuelve una divcon una clase de estilo background.
Dentro del div, hay un párrafo ( <p>) que contiene el texto "No encontrado".
Estilos:

Utilice estilos específicos definidos en el módulo CSS ( NotFound.module.css) para dar formato al fondo y posiblemente al texto.
Este componente probablemente se utiliza para mostrar una página amigable para el usuario cuando intenta acceder a una ruta que no existe en la aplicación. La página muestra el mensaje "No encontrado" y puede tener estilos específicos para mejorar la presentación visual. Es común utilizar este tipo de componentes para manejar rutas no definidas o errores de navegación.

**📍 About |** archivos:

About:
El componente Aboutes una sección que presenta información sobre la aplicación GymSpace. Aquí tienes una descripción del componente:

Importaciones:

React, { useState }: Importa React y el gancho useStatepara manejar el estado local.
Box, Typography, Card, CardContent, Button: Importa componentes de MUI para la estructura y estilo.
SearchIcon, ExploreIcon, FlashOnIcon, FitnessCenterIcon: Importa iconos de MUI.
styled: Importa la función styledde MUI para crear componentes con estilos personalizados.
createTheme, ThemeProvider: Importa funciones de MUI para temas y proveedores de temas.
Imágenes:

Defina dos imágenes ( FitnessImage1y FitnessImage2) que se utilizan en la sección de presentación.
Tema:

Crea un tema personalizado utilizando createThemeMUI.
Componentes estilizados:

AnimatedBox: Una Boxcon animación de escala al hacer hover.
AnimatedCard: Una Cardcon animación de opacidad y cambio de color de fondo al hace
IconContainer: Un contenedor estilizado para los iconos.
Componente de presentación:

Función Presentacionque representa la sección de presentación de GymSpace.
Utilice el estado local ( mensajey funciones relacionadas) para mostrar mensajes al hacer clic en diferentes secciones.
Incluye imágenes, texto descriptivo y secciones interactivas para "Optimizar", "Explorar" y "Potenciar".
Muestra la misión de GymSpace y un botón que lleva a un enlace externo.
Este componente parece ser una parte clave de la interfaz de usuario de la aplicación y proporciona información esencial sobre GymSpace, su propósito y funcionalidades.

**📍 Profile |** archivos:

Profile.jsx:
El componente Profile es responsable de mostrar el perfil del usuario. Aquí está una descripción del componente:

Importaciones:

Container, Box, Button: Componentes de MUI para estructurar y estilar la interfaz.
useSelector: Hook de React Redux para acceder al estado global de Redux.
Typography: Componente de MUI para mostrar texto con estilos.
useAuth0: Hook de Auth0 para acceder a la información de autenticación del usuario.
NotFound: Componente que se muestra si no hay un usuario autenticado.
BorderColorIcon: Icono de MUI que representa la edición del perfil.
useNavigate: Hook de React Router para la navegación programática.
Función del Componente:

Utiliza useAuth0para obtener información sobre el usuario autenticado.
Utilice useSelectorpara obtener información del perfil desde el estado de Redux.
Si hay un usuario autenticado, muestra la información del perfil.
Incluye la foto del usuario, nombre, apellido, botón para editar el perfil y detalles como fecha de nacimiento, dirección, género, teléfono y teléfono de contacto.
Si no hay un usuario autenticado, muestra el componente NotFound.
Botón de Edición de Perfil:

Utiliza un botón que, al hacer clic, navega a la ruta "/signUp" utilizando useNavigate.
Incluye el icono BorderColorIconpara indicar la acción de editar el perfil.
Este componente proporciona una interfaz simple pero completa para que los usuarios vean y editen sus perfiles. El uso de Redux y Auth0 agrega un nivel de integración con el estado de la aplicación y la autenticación del usuario.


**📍 Services |** archivos:

ServiceCard.js:
El componente ServiceCardes responsable de renderizar una tarjeta para mostrar información sobre un servicio. Aquí está una descripción del componente:

Importaciones:

React: Biblioteca principal de JavaScript para construir interfaces de usuario.
CardMedia, CardContent, CardActions, Typography: Componentes de MUI para estructurar y estilar la tarjeta.
SmallOrangeOutlinedButtonLess: Componente de botón personalizado con estilo.
ServicesCard, LinkNoDeco: Estilos personalizados para la tarjeta y un componente de enlace sin decoración.
Función del Componente:

Recibe un objeto servicecomo accesorio, que contiene información sobre el servicio.
Estructura visualmente la tarjeta del servicio con una imagen, información del servicio y botones de acción.
La imagen del servicio se muestra con un fondo de url(service.image).
Muestra la categoría del servicio en un encabezado con un estilo específico.
Muestra el nombre y la descripción del servicio.
Utilice un enlace ( LinkNoDeco) para redirigir a la ruta /ServiceDetail/${service.serviceID}al hacer clic en el botón "Ver".
Incluye un botón "Editar" que aún no tiene funcionalidad asociada.
Este componente es reutilizable y puede ser utilizado en una lista de servicios para mostrar información de cada servicio de manera estructurada y atractiva. La modularidad del componente facilita su integración en otras partes de la aplicación relacionadas con los servicios.

ServiceChip.js:
El componente ServiceChipes responsable de renderizar un chip que representa una categoría de servicio con la capacidad de ser eliminado. Aquí hay una descripción del componente:

Importaciones:

React: Biblioteca principal de JavaScript para construir interfaces de usuario.
Chip: Componente MUI que representa un chip.
ClearIcon: Icono de MUI que se utiliza como icono de eliminación en el chip.
Función del Componente:

Recibe las siguientes propiedades:

category: La categoría del servicio que se mostrará en el chip.
handleClearFilter: Función que se llama cuando se hace clic en el icono de eliminación del chip.
Estructura visualmente el chip con las características:

Etiqueta ( label): Muestra la categoría del servicio.
Eliminación ( onDelete): Llama a la función handleClearFiltercuando se hace clic en el icono de eliminación.
Icono de Eliminación ( deleteIcon): Utiliza el icono ClearIconen negro y negrita.
Color ( color): Usa el color secundario.
Estilos ( sx): Aplica estilos personalizados, como el color de fondo naranja, el color del texto negro y negrita.
Este componente es útil para representar visualmente las categorías de servicios seleccionados como chips en la interfaz de usuario. El icono de eliminación proporciona una forma conveniente de quitar una categoría de filtro.

ServiceFilter.js:
El componente ServiceFilteres responsable de renderizar un filtro de servicios en la interfaz de usuario. Aquí hay una descripción del componente:

Importaciones:

React: Biblioteca principal de JavaScript para construir interfaces de usuario.
Container: Componente de MUI que envuelve a otros componentes para proporcionar márgenes y rellenado.
CategoryIcon: Icono de MUI que representa una categoría.
AddCircleOutlineIcon: Icono de MUI que representa la acción de agregar.
LinkNoDeco: Componente de enlace sin decoración de MUI utilizado para la navegación.
OrangeOutlinedButton: Botón MUI con estilo personalizado.
StyledMenuy StyledMenuItem: Componentes de MUI utilizados para el menú y los elementos del menú, respectivamente.
useSelector: Hook de Redux que permite acceder al estado de la tienda Redux.
Función del Componente:

Recibe las siguientes propiedades:

categories: Un conjunto de categorías de servicios disponibles.
selectedCategories: Un conjunto de categorías de servicios seleccionados.
anchorEl: La posición del menú.
handleMenuClick: Función que se llama al hacer clic en el botón de categoría.
handleMenuItemClick: Función que se llama al hacer clic en un elemento del menú.
handleClose: Función que se llama para cerrar el menú.
Estructura visualmente el filtro de servicios con las siguientes características:

Botón "AÑADIR SERVICIO":
Solo se muestra si el usuario es un administrador o entrenador.
Redirige a la página de creación de servicios al hacer clic.
Botón de Categoría:
Muestra el icono de categoría.
Cambie el texto entre "Categorías seleccionadas" y "Seleccionar categoría" según si hay categorías seleccionadas.
Abra el menú de categorías al hacer clic.
Menú de Categorías:
Muestra una lista de categorías disponibles.
Se cierra al hacer clic en una categoría.
Este componente proporciona una interfaz intuitiva para que los usuarios seleccionen categorías de servicios y, en el caso de administradores o entrenadores, agreguen nuevos servicios.

services.js:
El componente Server se encarga de mostrar una colección de servicios y proporcionar filtros para seleccionar servicios basados ​​en categorías. Aquí está una descripción del componente:

Importaciones:

React, useState, useEffect: Bibliotecas principales de JavaScript para construir interfaces de usuario y trabajar con efectos secundarios y estados en componentes funcionales.
CssBaseline, Box, Container, ThemeProvider, Grid: Componentes de MUI utilizados para la estructura y estilo.
ServiceFilter: Componente para filtrar servicios por categoría.
ServiceChip: Componente para mostrar chips de categoría seleccionados.
ServiceCard: Componente para mostrar tarjetas de servicio.
Loading: Componente para mostrar un indicador de carga.
useSelector: Hook de Redux que permite acceder al estado de la tienda Redux.
useNavigate: Hook de React Router para la navegación programática.
Función del Componente:

Utilice el estado para gestionar la lista de servicios, categorías, categorías seleccionadas, el elemento de anclaje del menú y el estado de carga.
Utilice useEffectpara cargar la lista de servicios y categorías cuando el componente se monta.
Defina funciones para manejar los clics en el menú y los elementos del menú, así como para limpiar el filtro y cerrar el menú.
Renderiza un componente ServiceFilterpara permitir al usuario seleccionar categorías y filtrar servicios.
Renderiza chips de categoría seleccionados debajo del filtro.
Renderiza la colección de servicios en tarjetas, filtrando según las categorías seleccionadas.
Muestra un indicador de carga mientras los servicios se están cargando.
Este componente proporciona una interfaz interactiva para que los usuarios filtren y exploren servicios en función de categorías seleccionadas. Además, muestra una colección de tarjetas de servicio con información detallada.



**📍 Shopping |** archivos:

ShopCart.js:
El componente CartPage maneja la visualización del carrito de compras y permite al usuario interactuar con los elementos del carrito. Aquí hay una descripción del componente:

Importaciones:

React, useEffect, useState: Bibliotecas principales de JavaScript para construir interfaces de usuario y trabajar con efectos secundarios y estados en componentes funcionales.
Iconos de MUI: DeleteOutlined, AddCircleOutline, RemoveCircleOutline.
Componentes de MUI: Table, Button, Modal, Box, Typography, TextField, Select, MenuItem.
axios: Biblioteca para realizar solicitudes HTTP.
useNavigate: Hook de React Router para la navegación programática.
useLocalStorage: Hook personalizado para acceder y modificar datos en el almacenamiento local del navegador.
Estado:

cartItems: Almacena los elementos del carrito.
subTotal: Almacena el monto total del carrito antes de impuestos.
billPopup: Controla la visibilidad del modal para crear facturas.
Funciones:

handleIncrement: Incrementa la cantidad de un producto en el carrito.
handleDecrement: Decrementa la cantidad de un producto en el carrito.
handleDelete: Elimina un producto del carrito.
handleSubmit: Envia una solicitud para generar una factura con la información del carrito y muestra un modal para ingresar detalles adicionales del cliente y la factura.

Efectos:
Calcula el subtotal cada vez que cambian los elementos del carrito.
Renderizado:

Renderiza una tabla de productos en el carrito con opciones para incrementar, decrementar y eliminar productos.
Muestra el subtotal del carrito.
Proporciona un botón para crear una factura que abre un modal para ingresar detalles del cliente y la factura.
Almacenamiento Local:

Utiliza useLocalStorage para acceder y mostrar el contenido del almacenamiento local (por ejemplo, la variable local).
Este componente brinda al usuario la capacidad de gestionar su carrito de compras y generar facturas asociadas a los productos seleccionados.

**📍 UpdateUser |** archivos:

UpdateUser.jsx:
El componente UpdateUser está diseñado para actualizar la información de un usuario. Aquí hay una descripción de su estructura y funcionalidad:

Imports:

Se importan varios componentes y utilidades de MUI (Material-UI), incluyendo elementos como Container, TextField, Select, MenuItem, Button, Typography, Box, y DatePicker.
axios se utiliza para realizar solicitudes HTTP.
useNavigate y useParams son ganchos de React Router para la navegación y para obtener los parámetros de la URL, respectivamente.
useAuth0 es utilizado para gestionar la autenticación con Auth0.
dayjs es una biblioteca de manejo de fechas.
Estado:

userData: Almacena la información actual del usuario obtenida del servidor.
userUpdate: Almacena la información del usuario que se va a actualizar.
dateval: Almacena la fecha de nacimiento del usuario.
Efectos:

Se utiliza useEffect para obtener la información del usuario del servidor cuando el componente se monta.
Se utiliza otro useEffect para actualizar dateval cuando cambia la fecha de nacimiento del usuario.
Funciones:

getUser: Función asincrónica que obtiene la información del usuario del servidor utilizando Axios.
handleChange: Maneja el cambio en los campos de entrada y actualiza el estado correspondiente.
handleBirth: Convierte la fecha de nacimiento seleccionada en el formato deseado y actualiza el estado.
handleSubmit: Envía una solicitud para actualizar la información del usuario.
Renderizado:

Muestra un formulario con varios campos de entrada para la información del usuario, como nombre, apellido, correo electrónico, género, dirección, teléfono, etc.
Utiliza componentes de MUI para estilizar los elementos del formulario.
Incluye un botón para enviar la solicitud de actualización.
Estilos:

Aplica estilos personalizados a través de sx para cambiar colores, tamaños y otros estilos visuales.
Navegación:

Utiliza el gancho useNavigate para redirigir al usuario a la página de inicio después de la actualización exitosa.
Autenticación:

Utiliza useAuth0 para obtener el token de acceso necesario para realizar solicitudes autenticadas.
Este componente es esencial para permitir que los usuarios actualicen su información en la aplicación. La actualización de la interfaz de usuario se refleja en la interfaz de usuario mediante el uso de formularios y componentes de Material-UI.


**📍 Redux |** archivos:

actions, reducer y store: 
Actions:

Las acciones ( GET_USERy WARNING) son eventos que describen cambios en la aplicación. Pueden llevar datos asociados ( payload).
GET_USERse utiliza para almacenar la información del usuario en el estado global.
WARNINGse utiliza para cambiar el estado de advertencia en el estado global.

Reducer:

El reductor es una función pura que especifica cómo cambia el estado de la aplicación en respuesta a una acción.
El estado inicial ( initState) contiene propiedades como user(información del usuario) y warning(indicador de advertencia).
El reductor toma el estado actual y una acción, y devuelve un nuevo estado basado en la acción.
Store (Store):

La store es el objeto central de Redux que mantiene el estado de la aplicación.
Se crea con el reductor y, opcionalmente, middleware. En este caso, se utiliza redux-thunkpara manejar acciones asíncronas.
Despacho de Acciones:

Se pueden despachar acciones en cualquier parte de la aplicación usando la función dispatch. Por ejemplo, al cargar un componente o en respuesta a eventos.
Uso de acciones en componentes:

Los componentes pueden acceder al estado global utilizando funciones como useSelectoro connectsegún la elección de la implementación.
Los componentes pueden despachar acciones para actualizar el estado global.
Ejemplo de Flujo:

Un componente necesita la información del usuario, despacha la acción getUser.
El reductor GET_USERactualiza el estado global con la información del usuario.
Otro componente, observando el cambio en el estado global, actualiza su interfaz de usuario para mostrar la información del usuario.
Gestión Asíncrona (Opcional):

Se puede usar middleware como redux-thunkpara manejar acciones asíncronas, como solicitudes HTTP. Esto permite realizar operaciones asíncronas antes de despachar acciones.
Beneficios:

Centralización del estado: Todos los datos relevantes están en un solo lugar (estado global).
Predictibilidad: Las acciones y el estado son predecibles y fáciles de entender.
Escalabilidad: Facilita la gestión del estado en aplicaciones grandes y complejas.


**📍 Styles |** archivos:

ComponentStyles.css: 
Botones:

Se definen varios estilos para botones con diferentes propiedades como color, borde, radio de borde y comportamientos de hover.
Se utiliza el sistema styled de MUI para crear componentes con estilos específicos, como OrangeOutlinedButton o OrangeContainedButton.
Tarjetas (Cards):

Se define un estilo para las tarjetas (ProductCard y ServicesCard) que afecta propiedades como color de fondo, sombra y transiciones.
Menús y Elementos de Menú:

Se crea un estilo para el componente Menu y elementos de menú (StyledMenu, StyledMenuItemSelect, StyledMenuItem, StyledMenuItemBar).
Se ajustan propiedades como el color de fondo, la sombra y los colores de texto al hover.
Campo de Texto (TextField):

Se establece un estilo para los campos de texto (TextFieldForm) con propiedades como el color del texto, el color del borde y la transición en estados de hover y focus.
Lista y Elementos de Lista:

Se define un estilo para la lista (DashBoardList) y elementos de lista (DashBoardCategory, DashBoardListItem), especificando propiedades como el color del texto y el comportamiento de hover.
Otros Elementos:

Estilos para el componente Select (StyledSelect) y sus elementos relacionados.
Estilo para enlaces (LinkNoDeco) sin decoración de texto.
Variables Dinámicas:

Se utilizan variables dinámicas, como isSelected, para ajustar el color de fondo y el color del texto en ciertos casos, permitiendo una mayor flexibilidad y reutilización.
Responsividad:

No se evidencia directamente en el código proporcionado, pero la estructura y estilos están diseñados para adaptarse a diferentes tamaños de pantalla, especialmente teniendo en cuenta el uso de porcentajes y estilos flexibles.

**📍 Utils |** archivos:

authOUtils.js y constants.js:
 authOUtils.js:

Contiene una función llamada buildReqque recibe datos y la función getAccessTokenSilently.
Utiliza getAccessTokenSilentlypara obtener un token de acceso de Auth0 de forma asíncrona.
Construye y devuelve un objeto de solicitud ( req) que contiene el token de acceso en el encabezado ( Authorization: Bearer ${accessToken}) y los datos proporcionados.
constants.js:

Exporta una llamada constante API_URLque contiene la URL base de la API, presumiblemente utilizada para las aplicaciones a la API.

sellevara a cabo ciertas funcionalidades de extras como el responsive entre otros para una mejor y mayor experiencia en el App.

---

<br />

<div align="center">
<img src="./F1.svg" alt="" style="margin-top: 30px; width: 300px;" />
</div>